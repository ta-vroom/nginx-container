---
name: ðŸ”¨ Build Image
on:
  push:
    branches:
      - master
    paths-ignore:
      #- .github/**
      - '**/README.md'
  workflow_dispatch:

env:
  IMAGE_NAME: "angie"  # the name of the image produced by this build, matches repo names
  IMAGE_DESC: "Angie derived container image"
  ALPINE_VERSION: "3.19"
  IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"  # do not edit

concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}-${{ inputs.brand_name}}-${{ inputs.stream_name }}
  cancel-in-progress: true

jobs:
  build_push:
    name: Build and push image
    runs-on: ubuntu-24.04

    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      # These stage versions are pinned by https://github.com/renovatebot/renovate
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      # This is optional, but if you see that your builds are way too big for the runners, you can enable this by uncommenting the following lines:
      # - name: Maximize build space
      #   uses: ublue-os/remove-unwanted-software@517622d6452028f266b7ba4cc9a123b5f58a6b53 # v7
      #   with:
      #     remove-codeql: true
      
      - name: Get current date
        id: date
        run: |
          # This generates a timestamp like what is defined on the ArtifactHub documentation
          # E.G: 2022-02-08T15:38:15Z'
          # https://artifacthub.io/docs/topics/repositories/container-images/
          # https://linux.die.net/man/1/date
          echo "date=$(date -u +%Y\-%m\-%d\T%H\:%M\:%S\Z)" >> $GITHUB_OUTPUT

      # Image metadata for https://artifacthub.io/ - This is optional but is highly recommended so we all can get a index of all the custom images
      # The metadata by itself is not going to do anything, you choose if you want your image to be on ArtifactHub or not.
      - name: Image Metadata
        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 # v5
        id: metadata
        with:
          # This generates all the tags for your image, you can add custom tags here too!
          # By default, it should generate "latest" and "latest.(date here)".
          tags: |
            type=raw,value=latest
            type=raw,value=latest.{{date 'YYYYMMDD'}}
            type=raw,value={{date 'YYYYMMDD'}}
            type=sha,enable=${{ github.event_name == 'pull_request' }}
            type=ref,event=pr
          labels: |
            io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/refs/heads/main/README.md
            org.opencontainers.image.created=${{ steps.date.outputs.date }}
            org.opencontainers.image.description=${{ env.IMAGE_DESC }}
            org.opencontainers.image.documentation=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/refs/heads/main/README.md
            org.opencontainers.image.source=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/blob/main/Containerfile
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.url=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            io.artifacthub.package.deprecated=false
            io.artifacthub.package.prerelease=false
          sep-tags: " "
          sep-annotations: " "
      - name: Build Crowdsec
        id: crowdsec
        run: |
          IMGNAME="crowdsec-nginx-bouncer"
          CSNB_VER="v1.1.3"

          # Create build container
          ctr=$(buildah from --platform="${BUILDPLATFORM:-linux/amd64}" alpine:3.22.1)

          # Set up workdir
          buildah config --workingdir /src $ctr
          buildah config --shell '["/bin/ash", "-eo", "pipefail", "-c"]' $ctr

          # Upgrade base + install build deps
          buildah run $ctr -- apk upgrade --no-cache -a
          buildah run $ctr -- apk add --no-cache ca-certificates git build-base

          # Clone and build
          buildah run $ctr -- git clone --recursive https://github.com/crowdsecurity/cs-nginx-bouncer --branch "$CSNB_VER" /src
          buildah run $ctr -- make -C /src

          # Unpack tgz + rename dir
          buildah run $ctr -- sh -c 'tar xzf /src/crowdsec-nginx-bouncer.tgz && mv /src/crowdsec-nginx-bouncer-* /src/crowdsec-nginx-bouncer'

          # Patch configs
          buildah run $ctr -- sed -i "/lua_package_path/d" /src/crowdsec-nginx-bouncer/nginx/crowdsec_nginx.conf
          buildah run $ctr -- sed -i "/lua_ssl_trusted_certificate/d" /src/crowdsec-nginx-bouncer/nginx/crowdsec_nginx.conf
          buildah run $ctr -- sed -i "s|/etc/crowdsec/bouncers/crowdsec-nginx-bouncer.conf|/data/crowdsec/crowdsec.conf|g" /src/crowdsec-nginx-bouncer/nginx/crowdsec_nginx.conf
          buildah run $ctr -- sed -i "s|crowdsec-nginx-bouncer|crowdsec-npmplus-bouncer|g" /src/crowdsec-nginx-bouncer/nginx/crowdsec_nginx.conf

          # Patch lua-mod config_example.conf
          conf="/src/crowdsec-nginx-bouncer/lua-mod/config_example.conf"
          buildah run $ctr -- sed -i "s|API_KEY=.*|API_KEY=|g" "$conf"
          buildah run $ctr -- sed -i "s|ENABLED=.*|ENABLED=false|g" "$conf"
          buildah run $ctr -- sed -i "s|API_URL=.*|API_URL=http://127.0.0.1:8080|g" "$conf"
          buildah run $ctr -- sed -i "s|BAN_TEMPLATE_PATH=.*|BAN_TEMPLATE_PATH=/data/crowdsec/ban.html|g" "$conf"
          buildah run $ctr -- sed -i "s|CAPTCHA_TEMPLATE_PATH=.*|CAPTCHA_TEMPLATE_PATH=/data/crowdsec/captcha.html|g" "$conf"
          buildah run $ctr -- sed -i "s|APPSEC_URL=.*|APPSEC_URL=http://127.0.0.1:7422|g" "$conf"
          buildah run $ctr -- sed -i "s|APPSEC_FAILURE_ACTION=.*|APPSEC_FAILURE_ACTION=deny|g" "$conf"
          buildah run $ctr -- sed -i "s|REQUEST_TIMEOUT=.*|REQUEST_TIMEOUT=2500|g" "$conf"
          buildah run $ctr -- sed -i "s|APPSEC_CONNECT_TIMEOUT=.*|APPSEC_CONNECT_TIMEOUT=1000|g" "$conf"
          buildah run $ctr -- sed -i "s|APPSEC_SEND_TIMEOUT=.*|APPSEC_SEND_TIMEOUT=30000|g" "$conf"
          buildah run $ctr -- sed -i "s|APPSEC_PROCESS_TIMEOUT=.*|APPSEC_PROCESS_TIMEOUT=10000|g" "$conf"

          # Commit image
          buildah commit $ctr $IMGNAME

      - name: Build Angie
        id: build_image
        run: |
            buildah from --name ${{ env.IMAGE_NAME }} --platform=linux/amd64 --pull docker://docker.io/alpine:${{ env.ALPINE_VERSION }}
            
            BRS="buildah run ${{ env.IMAGE_NAME }} sh -c"

            $BRS "apk add --no-cache ca-certificates curl"
            $BRS "curl -o /etc/apk/keys/angie-signing.rsa https://angie.software/keys/angie-signing.rsa"
            $BRS 'echo "https://download.angie.software/angie/alpine/v${{ env.ALPINE_VERSION }}/main" >> /etc/apk/repositories'
            $BRS "apk add --no-cache angie angie-module-geoip2 angie-module-njs angie-module-lua"
            $BRS "apk add --no-cache lua5.1 luarocks lua5.1-cjson"
            $BRS "apk add --no-cache gettext"
            $BRS "rm /etc/apk/keys/angie-signing.rsa"
            $BRS "ln -sf /dev/stdout /var/log/angie/access.log"
            $BRS "ln -sf /dev/stderr /var/log/angie/error.log"

            buildah config --port 80 --port 443 ${{ env.IMAGE_NAME }}
            buildah config --cmd '["angie", "-g", "daemon off;"]' ${{ env.IMAGE_NAME }}

            
            # Make sure target dirs exist
            buildah run ${{env.IMAGE_NAME}} -- mkdir -p /usr/local/nginx/conf/conf.d/include
            buildah run ${{env.IMAGE_NAME}} -- mkdir -p /usr/local/nginx/lib/lua

            # Copy files from builder
            buildah copy --from=crowdsec-nginx-bouncer ${{env.IMAGE_NAME}} /src/crowdsec-nginx-bouncer/nginx/crowdsec_nginx.conf      /usr/local/nginx/conf/conf.d/include/crowdsec_nginx.conf
            buildah copy --from=crowdsec-nginx-bouncer ${{env.IMAGE_NAME}} /src/crowdsec-nginx-bouncer/lua-mod/config_example.conf    /usr/local/nginx/conf/conf.d/include/crowdsec.conf
            buildah copy --from=crowdsec-nginx-bouncer ${{env.IMAGE_NAME}} /src/crowdsec-nginx-bouncer/lua-mod/templates/captcha.html /usr/local/nginx/conf/conf.d/include/captcha.html
            buildah copy --from=crowdsec-nginx-bouncer ${{env.IMAGE_NAME}} /src/crowdsec-nginx-bouncer/lua-mod/templates/ban.html     /usr/local/nginx/conf/conf.d/include/ban.html
            buildah copy --from=crowdsec-nginx-bouncer ${{env.IMAGE_NAME}} /src/crowdsec-nginx-bouncer/lua-mod/lib/crowdsec.lua       /usr/local/nginx/lib/lua/crowdsec.lua
            buildah copy --from=crowdsec-nginx-bouncer ${{env.IMAGE_NAME}} /src/crowdsec-nginx-bouncer/lua-mod/lib/plugins            /usr/local/nginx/lib/lua/plugins
            
            for tag in ${{ steps.metadata.outputs.tags }}; do
              buildah commit ${{ env.IMAGE_NAME }} angie:$tag
            done


      # Rechunk is a script that we use on Universal Blue to make sure there isnt a single huge layer when your image gets published.
      # This does not make your image faster to download, just provides better resumability and fixes a few errors.
      # Documentation for Rechunk is provided on their github repository at https://github.com/hhd-dev/rechunk
      # You can enable it by uncommenting the following lines:
      # - name: Run Rechunker
      #   id: rechunk
      #   uses: hhd-dev/rechunk@f153348d8100c1f504dec435460a0d7baf11a9d2 # v1.1.1
      #   with:
      #     rechunk: 'ghcr.io/hhd-dev/rechunk:v1.0.1'
      #     ref: "localhost/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
      #     prev-ref: "${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
      #     skip_compression: true
      #     version: ${{ env.CENTOS_VERSION }}
      #     labels: ${{ steps.metadata.outputs.labels }} # Rechunk strips out all the labels during build, this needs to be reapplied here with newline separator

      # This is necessary so that the podman socket can find the rechunked image on its storage
      # - name: Load in podman and tag
      #   run: |
      #     IMAGE=$(podman pull ${{ steps.rechunk.outputs.ref }})
      #     sudo rm -rf ${{ steps.rechunk.outputs.output }}
      #     for tag in ${{ steps.metadata.outputs.tags }}; do
      #       podman tag $IMAGE ${{ env.IMAGE_NAME }}:$tag
      #     done

      # These `if` statements are so that pull requests for your custom images do not make it publish any packages under your name without you knowing
      # They also check if the runner is on the default branch so that things like the merge queue (if you enable it), are going to work
      - name: Login to GitHub Container Registry
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # v3
        # if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Workaround bug where capital letters in your GitHub username make it impossible to push to GHCR.
      # https://github.com/macbre/push-to-ghcr/issues/12
      - name: Lowercase Registry
        id: registry_case
        uses: ASzc/change-string-case-action@d0603cd0a7dd490be678164909f65c7737470a7f # v6
        with:
          string: ${{ env.IMAGE_REGISTRY }}

      - name: Lowercase Image
        id: image_case
        uses: ASzc/change-string-case-action@d0603cd0a7dd490be678164909f65c7737470a7f # v6
        with:
          string: ${{ env.IMAGE_NAME }}

      - name: Push To GHCR
        uses: redhat-actions/push-to-registry@5ed88d269cf581ea9ef6dd6806d01562096bee9c # v2
        #if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        id: push
        env:
          REGISTRY_USER: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ github.token }}
        with:
          registry: ${{ steps.registry_case.outputs.lowercase }}
          image: ${{ steps.image_case.outputs.lowercase }}
          tags: ${{ steps.metadata.outputs.tags }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

      # This section is optional and only needs to be enabled if you plan on distributing
      # your project for others to consume. You will need to create a public and private key
      # using Cosign and save the private key as a repository secret in Github for this workflow
      # to consume. For more details, review the image signing section of the README.
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3   # lightweight installer

      - name: Sign image with cosign
        env:
          COSIGN_EXPERIMENTAL: true
          #SIGN_KEY: ${{ secrets.PRIV_KEY }}
        run: |
          IMAGE_FULL="${{ steps.registry_case.outputs.lowercase }}/${{ steps.image_case.outputs.lowercase }}"
          DIGEST=$(skopeo inspect docker://$IMAGE_FULL --format '{{.Digest}}')

          if [ -z "$DIGEST" ]; then
            echo "ERROR: Failed to get image digest for $IMAGE_FULL"
            exit 1
          fi

          echo "Signing image: $IMAGE_FULL@$DIGEST"
          cosign sign -y "$IMAGE_FULL@$DIGEST"
